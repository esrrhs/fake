2014.8.4:建立hg
2014.8.4:添加variant
2014.8.5:添加flex和bison，初步添加语法
2014.8.5:bison编译通过
2014.8.5:程序编译通过，下一步加test测试内容
2014.8.13:添加syntree，下一步加语法树的生成，后面才能根据语法树编译成字节码
2014.8.14:加解析log
2014.8.15:加解析log，加新stmt
2014.8.16:加内存管理
2014.8.22:加func desc node
2014.8.26:加syntree node
2014.8.27:加syntree dump
2014.9.1:加编译
2014.9.2:加if cmp 的&&语句
2014.9.3:加value编译，下一步加codegen的输出
2014.9.4:加codegen的输出，下一步加运行
2014.9.5:加dump，下一步加运行
2014.9.5:加参数传递和简单运行，下一步加指令解析逻辑
2014.9.6:加错误信息，支持重载，加解释器和压栈，下一步加指令解析逻辑
2014.9.8:加assign的指令解析逻辑，下一步加return的
2014.9.10:修复bug，下一步解析3.fk
2014.9.12:解析3.fk成功，下一步加浮点数的支持
2014.9.13:加浮点数的支持，下一步解析4.fk
2014.9.14:加return的支持，已经能完成数学运算，下一步解析8.fk的if else指令
2014.9.15:加win32的支持，已能成功运行，下一步优化下运行时效率
2014.9.16:基本优化完毕，剩下的就是binary的map了，下一步解析8.fk
2014.9.16:解析8.fk完成，下一步解析9.fk
2014.9.16:解析9.fk完成，下一步添加内置函数，print接口
2014.9.17:执行9.fk比较和lua的差距大约差两倍，下一步加++和--接口，加完再进一步比较下
2014.9.17:优化后，执行9.fk比较和lua的差距是6s和7s，比较接近，下一步加++和--接口，加完再进一步比较下
2014.9.17:加+= -=等接口减少复制，加完9.fk效率和lua一样了
2014.9.18:后面继续对var进行优化，字符串改为引用方式，增加字符串池，去掉bool和int，一律用float，class改struct，构造析构能省则省，不行替换成宏
2014.9.18:改成lua方式，所有临时数据存放在fuck结构体中
2014.9.18:底层优化成c风格的，字符串处理todo，目前比lua速度还快点，运行9.fk 300w次，win下时间1s，linux下4s，lua分别是1s、5s
2014.9.18:优化func find，现在fuck 10s vs lua 16s，大幅提升性能，下一步加下bin的资源释放
2014.9.19:看了下luajit的实现，是在运行时在内存中编译好汇编码，然后设为可执行，然后再通过函数调用的方式跳转到这里，确实很巧妙，fs也实现下
2014.9.20:开始写fuckjit，把中间代码变成机器码运行
2014.9.21:fuckjit的2.fk调试通过，下一步编译3.fk
2014.9.22:添加数学运算，7.fk编译通过，jit比inter快3倍，下一步搞跳转语句
2014.9.23:搞定加等号和大与判断，下一步搞jmp就可以支持if和while了
2014.9.24:搞定jump，12.fk编译通过，速度果然快很多倍，下一步移植到win下
2014.9.25:win下不能支持嵌入汇编，加了个.asm，下一步写asm调用jit函数
2014.9.26:win下jit调试通过，记得得push各种寄存器再pop，下一步做函数调用
